/*
 * SineWave.h
 *
 *  Created on: Jun 30, 2020
 *      Author: Al
 */

#ifndef SINEWAVE_H_
#define SINEWAVE_H_

#include "Wave.h"
#include "AmplitudeEnvelope.h"
#include "FrequencyEnvelope.h"
#include  <vector>
#include  <cstdint>

/**
 *         Returns the number of samples that would be generated by make().
 * @param  seconds The time length.
 * @param  samplesPerSecond The sample rate.
 * @return the number of samples that would be generated by make().
 */
int length(double seconds, int samplesPerSecond) {
    return lround(samplesPerSecond * seconds);
}

/**
 *         Makes a sampled sine wave. Use length() to get the size of the returned array.
 * @param  magnitude The magnitude of the sine wave.
 * @param  frequency The frequency of the sine wave.
 * @param  radians The phase of the sine wave.
 * @param  seconds The time length of the sine wave.
 * @param  samplesPerSecond The sample rate.
 * @return A sampled sine wave.
 */
template<typename T>
std::vector<T> make(double magnitude, double frequency, double radians, double seconds,
                    int samplesPerSecond) {
    long samples = length(seconds, samplesPerSecond);
    std::vector<T> wave{};
    for (int i = 0; i < samples; i++) {
        wave.push_back(magnitude
                       * sin((2.0 * (M_PI) * frequency * i / samplesPerSecond) + radians));
    }
    return wave;
}

template<typename T>
std::vector<T> make(AmplitudeEnvelope amplitudeEnvelope, double frequency, double radians, int samplesPerSecond) {
    double amplitude = 1.0;
    std::vector<double> *amps = amplitudeEnvelope.getAmplitudes();
    double seconds = (double)(amps->size()) / samplesPerSecond;
    std::vector<T> wave = make<T>(amplitude, frequency, radians, seconds, samplesPerSecond);
    if(std::is_same<T, float>::value){
        for (int i = 0; i < wave.size(); i++) {
            wave[i] = wave[i] * (*amps)[i];
        }
    }
    if(std::is_same<T, int16_t>::value) {
        for (int i = 0; i < wave.size(); i++) {
            wave[i] = lround(wave[i] * (*amps)[i]);
        }
    }
    return wave;
}

template<typename T>
std::vector<T> make(double magnitude, FrequencyEnvelope frequencyEnvelope, double radians, int samplesPerSecond) {
    std::vector<double> *freqs = frequencyEnvelope.getFrequencies();
    double rads = radians;
    double seconds = 1.0 / samplesPerSecond;
    std::vector<T> wave{};
    for(int i = 0; i < freqs->size(); i++) {
        std::vector<T> newWave = make<T>(magnitude, (*freqs)[i], rads, seconds,
                                         samplesPerSecond);
        wave.insert(wave.end(), newWave.begin(), newWave.end());
        rads += 2.0*M_PI*((*freqs)[i])*seconds;
    }
    return wave;
}

template<typename T>
std::vector<T> make(AmplitudeEnvelope amplitudeEnvelope, FrequencyEnvelope frequencyEnvelope, double radians, int samplesPerSecond) {
    if(amplitudeEnvelope.getAmplitudes()->size() != frequencyEnvelope.getFrequencies()->size()){
        throw std::logic_error("amplitudeEnvelope and frequencyEnvelope passed to make are not the same length");
    }
    std::vector<double> *amps = amplitudeEnvelope.getAmplitudes();
    std::vector<double> *freqs = frequencyEnvelope.getFrequencies();
    double rads = radians;
    double seconds = 1.0 / samplesPerSecond;
    std::vector<T> wave{};
    for(int i = 0; i < freqs->size(); i++) {
        std::vector<T> newWave = make<T>((*amps)[i], (*freqs)[i], rads, seconds,
                                         samplesPerSecond);
        wave.insert(wave.end(), newWave.begin(), newWave.end());
        rads += 2.0*M_PI*((*freqs)[i])*seconds;
    }
    return wave;
}

#endif /* SINEWAVE_H_ */